{(u : (num, num)) (v : (num, num))}
`{(a : num)}

/* let (u0, u1) = ScaleVec a u; */
let (u0', u1') = u;
let u0 = dmul a u0';
let u1 = dmul a u1';

let (v0, v1) = v;
let x = add u0 v0;
let y = add u1 v1;
add x y 

/* this gives backward error of 3e for u instead of 2e, like in the paper */
/* but I think 3e is actually correct since (dmul, add, add) are applied to
   both u0 and u1 */